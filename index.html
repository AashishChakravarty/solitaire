<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Klondike Solitaire</title>
    <style>
      /* --- Basic Setup & Typography --- */
      :root {
        --card-width: 100px;
        --card-height: 140px;
        --card-border-radius: 8px;
        --board-gap: 15px;
        --felt-green: #2a623d;
        --felt-green-dark: #1e472c;
        --card-back: #4a90e2;
        --card-back-pattern: #357abd;
        --animation-speed: 0.2s;
        --move-animation-speed: 0.3s;
      }

      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

      html {
        height: 100%;
      }

      body {
        background-color: var(--felt-green);
        font-family: 'Inter', sans-serif;
        color: white;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        min-height: 100vh;
        padding: 20px;
        box-sizing: border-box;
        -webkit-user-select: none; /* Safari */
        -ms-user-select: none; /* IE 10 and IE 11 */
        user-select: none; /* Standard syntax */
        overflow: hidden;
      }

      #game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
      }

      .top-bar {
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        max-width: calc(7 * var(--card-width) + 6 * var(--board-gap));
        flex-shrink: 0;
      }

      .score-container {
        font-size: 1.2rem;
        font-weight: 600;
        background-color: rgba(0, 0, 0, 0.2);
        padding: 8px 15px;
        border-radius: var(--card-border-radius);
        text-align: right;
      }

      /* --- Game Controls --- */
      .game-controls {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 15px;
        margin-bottom: 20px;
        flex-shrink: 0;
      }

      .control-button {
        background-color: #ffffff;
        color: var(--felt-green-dark);
        border: none;
        padding: 10px 20px;
        border-radius: var(--card-border-radius);
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: background-color 0.2s, transform 0.2s, color 0.2s;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .control-button:hover {
        background-color: #f0f0f0;
        transform: translateY(-2px);
      }

      .control-button:disabled {
        background-color: #cccccc;
        color: #666666;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      #hint-btn {
        background: linear-gradient(45deg, #fdd835, #f57f17);
        color: var(--felt-green-dark);
      }
      #hint-btn:hover {
        transform: translateY(-2px) scale(1.05);
      }

      #auto-complete-btn {
        background: linear-gradient(45deg, #6a11cb 0%, #2575fc 100%);
        color: white;
        display: none; /* Hidden by default */
      }

      /* --- Game Board Layout --- */
      .game-board {
        display: grid;
        grid-template-columns: repeat(7, var(--card-width));
        grid-template-rows: var(--card-height) auto;
        gap: var(--board-gap);
        justify-content: center;
        width: 100%;
        max-width: calc(7 * var(--card-width) + 6 * var(--board-gap));
        position: relative;
        padding-bottom: 30px;
      }

      .top-piles {
        grid-column: 1 / span 7;
        display: flex;
        justify-content: space-between;
      }

      .stock-waste-piles,
      .foundation-piles {
        display: flex;
        gap: var(--board-gap);
      }

      .tableau-piles {
        grid-column: 1 / span 7;
        display: contents;
      }

      /* --- Card Piles (Empty Slots) --- */
      .pile,
      .card {
        width: var(--card-width);
        height: var(--card-height);
        border-radius: var(--card-border-radius);
      }

      .pile {
        border: 2px dashed rgba(255, 255, 255, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2rem;
        color: rgba(255, 255, 255, 0.3);
        position: relative;
      }

      .pile.foundation::before {
        position: absolute;
        opacity: 0.2;
        font-size: 4rem;
      }

      .pile.foundation.hearts::before {
        content: 'â™¥';
        color: red;
      }
      .pile.foundation.diamonds::before {
        content: 'â™¦';
        color: red;
      }
      .pile.foundation.clubs::before {
        content: 'â™£';
        color: black;
      }
      .pile.foundation.spades::before {
        content: 'â™ ';
        color: black;
      }

      .tableau-pile {
        position: relative;
        height: auto;
        min-height: var(--card-height);
      }

      /* --- Card Styling & Animations --- */
      .card {
        background-color: white;
        border: 1px solid #ccc;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        position: absolute;
        cursor: pointer;
        transition: transform var(--animation-speed) ease-in-out, box-shadow var(--animation-speed) ease-in-out, top var(--animation-speed) ease-out,
          left var(--animation-speed) ease-out;
        display: flex;
        align-items: center;
        justify-content: center;
        box-sizing: border-box;
        transform-style: preserve-3d;
      }

      .card.ghost {
        visibility: hidden;
      }

      .card.moving {
        position: fixed;
        z-index: 100;
        transition: top var(--move-animation-speed) ease-in-out, left var(--move-animation-speed) ease-in-out;
      }

      .card.dragging {
        opacity: 0.7;
        transform: scale(1.05);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      }

      .card.flipping {
        animation: flip var(--animation-speed) ease-in-out forwards;
      }

      @keyframes flip {
        from {
          transform: rotateY(180deg);
        }
        to {
          transform: rotateY(0deg);
        }
      }

      .hint-highlight {
        animation: hint-shake 0.5s ease-in-out;
        box-shadow: 0 0 20px 5px #ffeb3b; /* A yellow glow */
      }

      @keyframes hint-shake {
        0%,
        100% {
          transform: translateX(0) scale(1);
        }
        25% {
          transform: translateX(-5px) scale(1.05);
        }
        75% {
          transform: translateX(5px) scale(1.05);
        }
      }

      .card.red {
        color: #d92e2e;
      }
      .card.black {
        color: #222222;
      }

      .card-corner {
        position: absolute;
        font-size: 1.1rem;
        line-height: 1;
        font-weight: 600;
      }
      .card-corner.top {
        top: 5px;
        left: 7px;
      }
      .card-corner.bottom {
        bottom: 5px;
        right: 7px;
        transform: rotate(180deg);
      }
      .card-suit-main {
        font-size: 2.8rem;
      }

      .card.face-down {
        background-color: var(--card-back);
        background-image: repeating-linear-gradient(45deg, var(--card-back-pattern), var(--card-back-pattern) 10px, transparent 10px, transparent 20px);
        color: transparent;
        cursor: default;
        transform: rotateY(180deg);
      }

      .stock .card.face-down {
        cursor: pointer;
      }

      #stock-pile.empty::before {
        content: 'âŸ³';
        font-size: 3rem;
        color: rgba(255, 255, 255, 0.5);
        cursor: pointer;
      }

      .tableau-pile .card {
        position: absolute;
        left: 0;
        top: 0;
      }

      .pile.drag-over {
        border-color: #fff;
        border-style: solid;
        background-color: rgba(255, 255, 255, 0.1);
      }

      /* --- Modal Styling --- */
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6);
        align-items: center;
        justify-content: center;
      }

      .modal-content {
        background-color: #fefefe;
        color: var(--felt-green-dark);
        padding: 30px 40px;
        border-radius: var(--card-border-radius);
        text-align: center;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        max-width: 90%;
        width: 400px;
        animation: modal-fade-in 0.3s ease-out;
      }

      @keyframes modal-fade-in {
        from {
          opacity: 0;
          transform: scale(0.9);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }

      .modal-content h2 {
        margin-top: 0;
        font-size: 2.5rem;
      }

      /* --- Responsive Design --- */
      @media (max-width: 800px) {
        :root {
          --card-width: 80px;
          --card-height: 112px;
          --board-gap: 10px;
        }
        body {
          padding: 10px;
        }
        .game-board {
          max-width: 100%;
        }
      }
      @media (max-width: 600px) {
        :root {
          --card-width: calc((100vw - 80px) / 7);
          --card-height: calc(var(--card-width) * 1.4);
        }
        .card {
          font-size: 1rem;
        }
        .card-suit-main {
          font-size: 2rem;
        }
        .card-corner {
          font-size: 1rem;
        }
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <div class="top-bar">
        <div class="game-controls">
          <button id="new-game-btn" class="control-button">New Game</button>
          <button id="restart-btn" class="control-button">Restart</button>
          <button id="undo-btn" class="control-button" disabled>Undo</button>
          <button id="hint-btn" class="control-button">ðŸ’¡ Hint</button>
          <button id="auto-complete-btn" class="control-button">Auto-Complete</button>
        </div>
        <div class="score-container">
          <div id="score-display">Score: 0</div>
          <div id="high-score-display">High Score: 0</div>
        </div>
      </div>

      <div class="game-board">
        <div class="top-piles">
          <div class="stock-waste-piles">
            <div id="stock-pile" class="pile stock"></div>
            <div id="waste-pile" class="pile waste"></div>
          </div>
          <div class="foundation-piles">
            <div id="foundation-0" data-suit="hearts" class="pile foundation hearts"></div>
            <div id="foundation-1" data-suit="diamonds" class="pile foundation diamonds"></div>
            <div id="foundation-2" data-suit="clubs" class="pile foundation clubs"></div>
            <div id="foundation-3" data-suit="spades" class="pile foundation spades"></div>
          </div>
        </div>
        <div class="tableau-piles">
          <div id="tableau-0" class="pile tableau-pile"></div>
          <div id="tableau-1" class="pile tableau-pile"></div>
          <div id="tableau-2" class="pile tableau-pile"></div>
          <div id="tableau-3" class="pile tableau-pile"></div>
          <div id="tableau-4" class="pile tableau-pile"></div>
          <div id="tableau-5" class="pile tableau-pile"></div>
          <div id="tableau-6" class="pile tableau-pile"></div>
        </div>
      </div>
    </div>

    <div id="win-modal" class="modal">
      <div class="modal-content">
        <h2>You Win!</h2>
        <p>Congratulations, you cleared the board!</p>
        <button id="win-new-game-btn" class="control-button">Play Again</button>
      </div>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Elements ---
        const scoreDisplayEl = document.getElementById('score-display');
        const highScoreDisplayEl = document.getElementById('high-score-display');
        const gameBoardEl = document.querySelector('.game-board');
        const stockPileEl = document.getElementById('stock-pile');
        const wastePileEl = document.getElementById('waste-pile');
        const foundationPileEls = document.querySelectorAll('.foundation-piles .pile');
        const tableauPileEls = document.querySelectorAll('.tableau-piles .pile');
        const newGameBtn = document.getElementById('new-game-btn');
        const restartBtn = document.getElementById('restart-btn');
        const undoBtn = document.getElementById('undo-btn');
        const hintBtn = document.getElementById('hint-btn');
        const autoCompleteBtn = document.getElementById('auto-complete-btn');

        // Modals
        const winModal = document.getElementById('win-modal');
        const winNewGameBtn = document.getElementById('win-new-game-btn');

        // --- Game State Variables ---
        const SUITS = ['â™¥', 'â™¦', 'â™£', 'â™ '];
        const VALUES = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const VALUE_MAP = { A: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, J: 11, Q: 12, K: 13 };
        const SUIT_TO_INDEX_MAP = { 'â™¥': 0, 'â™¦': 1, 'â™£': 2, 'â™ ': 3 };

        let stock = [];
        let waste = [];
        let foundations = [[], [], [], []];
        let tableau = [[], [], [], [], [], [], []];

        let initialGameState = {}; // For the restart button
        let lastGameState = null; // For the undo button
        let isAnimating = false;
        let score = 0;
        let highScore = 0;

        // Drag and Drop State
        let draggedCards = [];
        let sourcePile = null;
        let sourceElement = null;

        // --- Game Initialization ---

        function createDeck() {
          return SUITS.flatMap((suit) => {
            return VALUES.map((value) => {
              const color = suit === 'â™¥' || suit === 'â™¦' ? 'red' : 'black';
              return { suit, value, color, faceUp: false };
            });
          });
        }

        function shuffleDeck(deck) {
          for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
          }
          return deck;
        }

        function dealCards(deck) {
          for (let i = 0; i < 7; i++) {
            for (let j = i; j < 7; j++) {
              tableau[j].push(deck.pop());
            }
          }
          tableau.forEach((pile) => {
            if (pile.length > 0) {
              pile[pile.length - 1].faceUp = true;
            }
          });
          stock = deck;
        }

        function saveInitialState() {
          initialGameState = {
            stock: JSON.parse(JSON.stringify(stock)),
            tableau: JSON.parse(JSON.stringify(tableau)),
          };
        }

        function startGame() {
          stock = [];
          waste = [];
          foundations = [[], [], [], []];
          tableau = [[], [], [], [], [], [], []];
          winModal.style.display = 'none';
          lastGameState = null;
          undoBtn.disabled = true;
          autoCompleteBtn.style.display = 'none';
          isAnimating = false;
          score = 0;
          highScore = getHighScore();
          updateScore(0);

          const fullDeck = createDeck();
          const shuffledDeck = shuffleDeck(fullDeck);
          dealCards(shuffledDeck);
          saveInitialState();
          renderAll();
        }

        function restartGame() {
          if (!initialGameState.stock || !initialGameState.tableau) return;
          stock = JSON.parse(JSON.stringify(initialGameState.stock));
          tableau = JSON.parse(JSON.stringify(initialGameState.tableau));
          waste = [];
          foundations = [[], [], [], []];
          winModal.style.display = 'none';
          lastGameState = null;
          undoBtn.disabled = true;
          autoCompleteBtn.style.display = 'none';
          isAnimating = false;
          score = 0;
          updateScore(0);
          renderAll();
        }

        // --- Rendering Logic ---

        function renderAll() {
          renderStock();
          renderWaste();
          renderFoundations();
          renderTableau();
          checkAutoComplete();
        }

        function createCardElement(card) {
          const cardEl = document.createElement('div');
          cardEl.classList.add('card', card.color);
          cardEl.dataset.value = card.value;
          cardEl.dataset.suit = card.suit;

          if (card.faceUp) {
            cardEl.innerHTML = `
                        <span class="card-corner top">${card.value}${card.suit}</span>
                        <span class="card-suit-main">${card.suit}</span>
                        <span class="card-corner bottom">${card.value}${card.suit}</span>
                    `;
            cardEl.draggable = true;
          } else {
            cardEl.classList.add('face-down');
          }
          return cardEl;
        }

        function renderStock() {
          stockPileEl.innerHTML = '';
          stockPileEl.classList.toggle('empty', stock.length === 0);
          if (stock.length > 0) {
            const topCard = stock[stock.length - 1];
            const cardEl = createCardElement(topCard);
            stockPileEl.appendChild(cardEl);
          }
        }

        function renderWaste() {
          wastePileEl.innerHTML = '';
          if (waste.length > 0) {
            const topCard = waste[waste.length - 1];
            const cardEl = createCardElement(topCard);
            wastePileEl.appendChild(cardEl);
          }
        }

        function renderFoundations() {
          foundationPileEls.forEach((pileEl, index) => {
            pileEl.innerHTML = '';
            const pile = foundations[index];
            if (pile.length > 0) {
              const topCard = pile[pile.length - 1];
              const cardEl = createCardElement(topCard);
              pileEl.appendChild(cardEl);
            }
          });
        }

        function renderTableau() {
          tableauPileEls.forEach((pileEl, index) => {
            pileEl.innerHTML = '';
            const pile = tableau[index];
            pile.forEach((card, cardIndex) => {
              const cardEl = createCardElement(card);
              cardEl.style.top = `${cardIndex * 30}px`;
              pileEl.appendChild(cardEl);
            });
          });
        }

        // --- Game Logic, Rules & Scoring ---

        function updateScore(change) {
          score = Math.max(0, score + change);
          if (score > highScore) {
            highScore = score;
            setHighScore(highScore);
          }
          scoreDisplayEl.textContent = `Score: ${score}`;
          highScoreDisplayEl.textContent = `High Score: ${highScore}`;
        }

        function getHighScore() {
          return parseInt(localStorage.getItem('solitaireHighScore') || '0');
        }

        function setHighScore(newHighScore) {
          localStorage.setItem('solitaireHighScore', newHighScore);
        }

        function saveStateForUndo() {
          lastGameState = {
            stock: JSON.parse(JSON.stringify(stock)),
            waste: JSON.parse(JSON.stringify(waste)),
            foundations: JSON.parse(JSON.stringify(foundations)),
            tableau: JSON.parse(JSON.stringify(tableau)),
            score: score,
          };
          undoBtn.disabled = false;
        }

        function undoMove() {
          if (!lastGameState || isAnimating) return;
          stock = lastGameState.stock;
          waste = lastGameState.waste;
          foundations = lastGameState.foundations;
          tableau = lastGameState.tableau;
          score = lastGameState.score;
          updateScore(0);
          lastGameState = null;
          undoBtn.disabled = true;
          renderAll();
        }

        function canPlaceOnFoundation(card, foundationPile) {
          const topCard = foundationPile.length > 0 ? foundationPile[foundationPile.length - 1] : null;
          const cardValue = VALUE_MAP[card.value];
          if (!topCard) return cardValue === 1;
          return card.suit === topCard.suit && cardValue === VALUE_MAP[topCard.value] + 1;
        }

        function canPlaceOnTableau(cards, tableauPile) {
          const movingCard = cards[0];
          const topCard = tableauPile.length > 0 ? tableauPile[tableauPile.length - 1] : null;
          if (!topCard) return VALUE_MAP[movingCard.value] === 13;
          return movingCard.color !== topCard.color && VALUE_MAP[movingCard.value] === VALUE_MAP[topCard.value] - 1;
        }

        function flipTopTableauCard(pile, pileEl) {
          return new Promise((resolve) => {
            if (pile.length > 0) {
              const topCard = pile[pile.length - 1];
              if (!topCard.faceUp) {
                updateScore(5);
                topCard.faceUp = true;
                const cardEl = pileEl.children[pile.length - 1];
                if (cardEl && cardEl.classList.contains('face-down')) {
                  cardEl.classList.add('flipping');
                  setTimeout(() => {
                    cardEl.classList.remove('face-down');
                    cardEl.draggable = true;
                    cardEl.innerHTML = `
                                        <span class="card-corner top">${topCard.value}${topCard.suit}</span>
                                        <span class="card-suit-main">${topCard.suit}</span>
                                        <span class="card-corner bottom">${topCard.value}${topCard.suit}</span>
                                    `;
                  }, (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--animation-speed')) * 1000) / 2);
                  setTimeout(() => {
                    cardEl.classList.remove('flipping');
                    resolve(true);
                  }, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--animation-speed')) * 1000);
                  return;
                }
              }
            }
            resolve(false);
          });
        }

        function checkWinCondition() {
          const totalCardsInFoundations = foundations.reduce((sum, pile) => sum + pile.length, 0);
          if (totalCardsInFoundations === 52) {
            setTimeout(() => (winModal.style.display = 'flex'), 500);
          }
        }

        // --- Hint System ---
        function findHint() {
          // 1. Waste to Foundation
          if (waste.length > 0) {
            const card = waste[waste.length - 1];
            const foundationIndex = SUIT_TO_INDEX_MAP[card.suit];
            if (canPlaceOnFoundation(card, foundations[foundationIndex])) {
              return {
                sourceEl: wastePileEl.firstElementChild,
                targetEl: foundationPileEls[foundationIndex],
              };
            }
          }

          // 2. Tableau to Foundation
          for (let i = 0; i < tableau.length; i++) {
            if (tableau[i].length > 0) {
              const card = tableau[i][tableau[i].length - 1];
              const foundationIndex = SUIT_TO_INDEX_MAP[card.suit];
              if (canPlaceOnFoundation(card, foundations[foundationIndex])) {
                return {
                  sourceEl: tableauPileEls[i].lastElementChild,
                  targetEl: foundationPileEls[foundationIndex],
                };
              }
            }
          }

          // 3. Waste to Tableau
          if (waste.length > 0) {
            const card = waste[waste.length - 1];
            for (let i = 0; i < tableau.length; i++) {
              if (canPlaceOnTableau([card], tableau[i])) {
                return {
                  sourceEl: wastePileEl.firstElementChild,
                  targetEl: tableauPileEls[i],
                };
              }
            }
          }

          // 4. Tableau to Tableau
          for (let i = 0; i < tableau.length; i++) {
            // Source pile
            if (tableau[i].length > 0) {
              for (let j = 0; j < tableau[i].length; j++) {
                if (tableau[i][j].faceUp) {
                  const stackToMove = tableau[i].slice(j);
                  for (let k = 0; k < tableau.length; k++) {
                    // Destination pile
                    if (i === k) continue;
                    if (canPlaceOnTableau(stackToMove, tableau[k])) {
                      return {
                        sourceEl: tableauPileEls[i].children[j],
                        targetEl: tableauPileEls[k],
                      };
                    }
                  }
                }
              }
            }
          }

          // 5. Stock to Waste
          if (stock.length > 0) {
            return {
              sourceEl: stockPileEl,
              targetEl: wastePileEl,
            };
          }

          // 6. Reset Waste to Stock
          if (stock.length === 0 && waste.length > 0) {
            return {
              sourceEl: stockPileEl,
              targetEl: stockPileEl,
            };
          }

          return null; // No hint found
        }

        function showHint() {
          if (isAnimating) return;
          const hint = findHint();
          if (hint) {
            isAnimating = true;
            updateScore(-5); // Hint penalty

            const { sourceEl, targetEl } = hint;

            sourceEl.classList.add('hint-highlight');
            targetEl.classList.add('hint-highlight');

            setTimeout(() => {
              sourceEl.classList.remove('hint-highlight');
              targetEl.classList.remove('hint-highlight');
              isAnimating = false;
            }, 600);
          } else {
            const originalText = hintBtn.textContent;
            hintBtn.textContent = 'No Moves!';
            hintBtn.disabled = true;
            setTimeout(() => {
              hintBtn.textContent = 'ðŸ’¡ Hint';
              hintBtn.disabled = false;
            }, 1000);
          }
        }

        // --- New Features: Animations, Double Click, Auto-Complete ---

        function animateCardMove(cardEl, targetEl) {
          return new Promise((resolve) => {
            const startRect = cardEl.getBoundingClientRect();
            const targetRect = targetEl.getBoundingClientRect();

            let targetTop = targetRect.top;
            if (targetEl.id.startsWith('tableau')) {
              const pileIndex = parseInt(targetEl.id.split('-')[1]);
              targetTop += tableau[pileIndex].length * 30;
            }

            const movingEl = cardEl.cloneNode(true);
            movingEl.classList.add('moving');
            document.body.appendChild(movingEl);
            movingEl.style.top = `${startRect.top}px`;
            movingEl.style.left = `${startRect.left}px`;

            cardEl.classList.add('ghost');

            requestAnimationFrame(() => {
              movingEl.style.top = `${targetTop}px`;
              movingEl.style.left = `${targetRect.left}px`;
            });

            setTimeout(() => {
              document.body.removeChild(movingEl);
              cardEl.classList.remove('ghost');
              resolve();
            }, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--move-animation-speed')) * 1000);
          });
        }

        function checkAutoComplete() {
          const isStockEmpty = stock.length === 0 && waste.length === 0;
          const allTableauFaceUp = tableau.every((pile) => pile.every((card) => card.faceUp));
          if (isStockEmpty && allTableauFaceUp) {
            autoCompleteBtn.style.display = 'inline-block';
          } else {
            autoCompleteBtn.style.display = 'none';
          }
        }

        async function startAutoComplete() {
          isAnimating = true;
          autoCompleteBtn.disabled = true;
          undoBtn.disabled = true;

          let movableCardFound = true;
          while (movableCardFound) {
            movableCardFound = false;

            for (let i = 0; i < tableau.length; i++) {
              if (tableau[i].length > 0) {
                const card = tableau[i][tableau[i].length - 1];
                const foundationIndex = SUIT_TO_INDEX_MAP[card.suit];
                if (canPlaceOnFoundation(card, foundations[foundationIndex])) {
                  updateScore(15);
                  await animateCardMove(tableauPileEls[i].lastElementChild, foundationPileEls[foundationIndex]);
                  foundations[foundationIndex].push(tableau[i].pop());
                  renderAll();
                  movableCardFound = true;
                  break;
                }
              }
            }
          }
          isAnimating = false;
          checkWinCondition();
        }

        // --- Event Handlers ---

        stockPileEl.addEventListener('click', () => {
          if (isAnimating) return;
          saveStateForUndo();
          if (stock.length > 0) {
            const card = stock.pop();
            card.faceUp = true;
            waste.push(card);
          } else if (waste.length > 0) {
            stock = waste.reverse().map((card) => ({ ...card, faceUp: false }));
            waste = [];
          }
          renderAll();
        });

        document.addEventListener('dragstart', (e) => {
          if (isAnimating || !e.target.classList.contains('card') || e.target.classList.contains('face-down')) {
            e.preventDefault();
            return;
          }
          sourceElement = e.target;
          setTimeout(() => sourceElement.classList.add('dragging'), 0);
          const parentId = sourceElement.parentElement.id;
          if (parentId.startsWith('tableau')) {
            const pileIndex = parseInt(parentId.split('-')[1]);
            const cardIndex = Array.from(sourceElement.parentElement.children).indexOf(sourceElement);
            sourcePile = { type: 'tableau', index: pileIndex };
            draggedCards = tableau[pileIndex].slice(cardIndex);
          } else if (parentId === 'waste-pile') {
            sourcePile = { type: 'waste' };
            draggedCards = [waste[waste.length - 1]];
          } else if (parentId.startsWith('foundation')) {
            const pileIndex = parseInt(parentId.split('-')[1]);
            sourcePile = { type: 'foundation', index: pileIndex };
            draggedCards = [foundations[pileIndex][foundations[pileIndex].length - 1]];
          }
        });

        document.addEventListener('dragover', (e) => e.preventDefault());
        document.addEventListener('dragleave', (e) => {});
        document.addEventListener('dragend', () => {
          if (sourceElement) sourceElement.classList.remove('dragging');
        });

        document.addEventListener('drop', async (e) => {
          e.preventDefault();
          if (isAnimating) return;
          const dropTarget = e.target.closest('.pile');
          if (!dropTarget || !sourcePile) return;

          const targetId = dropTarget.id;
          let moveSuccessful = false;

          if (targetId.startsWith('foundation')) {
            const foundationIndex = parseInt(targetId.split('-')[1]);
            const card = draggedCards[0];
            if (draggedCards.length === 1 && SUIT_TO_INDEX_MAP[card.suit] === foundationIndex && canPlaceOnFoundation(card, foundations[foundationIndex])) {
              foundations[foundationIndex].push(card);
              moveSuccessful = true;
              updateScore(15);
            }
          } else if (targetId.startsWith('tableau')) {
            const tableauIndex = parseInt(targetId.split('-')[1]);
            if (canPlaceOnTableau(draggedCards, tableau[tableauIndex])) {
              tableau[tableauIndex].push(...draggedCards);
              moveSuccessful = true;
              if (sourcePile.type === 'waste') updateScore(5);
            }
          }

          if (moveSuccessful) {
            saveStateForUndo();
            if (sourcePile.type === 'waste') waste.pop();
            else if (sourcePile.type === 'foundation') {
              foundations[sourcePile.index].pop();
              updateScore(-15);
            } else if (sourcePile.type === 'tableau') {
              const sourceTableauPile = tableau[sourcePile.index];
              const sourceTableauEl = tableauPileEls[sourcePile.index];
              sourceTableauPile.splice(-draggedCards.length);
              await flipTopTableauCard(sourceTableauPile, sourceTableauEl);
            }
            renderAll();
            checkWinCondition();
          }
        });

        gameBoardEl.addEventListener('dblclick', async (e) => {
          if (isAnimating) return;
          const cardEl = e.target.closest('.card');
          if (!cardEl || cardEl.classList.contains('face-down')) return;

          const parentId = cardEl.parentElement.id;
          let card, sourceArray, sourceEl;
          let sourceWasTableau = false;
          let sourceTableauPileIndex = -1;

          if (parentId === 'waste-pile' && waste.length > 0) {
            card = waste[waste.length - 1];
            sourceArray = waste;
            sourceEl = wastePileEl.firstElementChild;
          } else if (parentId.startsWith('tableau')) {
            const pileIndex = parseInt(parentId.split('-')[1]);
            const pile = tableau[pileIndex];
            if (pile.length > 0 && cardEl === tableauPileEls[pileIndex].lastElementChild) {
              card = pile[pile.length - 1];
              sourceArray = pile;
              sourceEl = tableauPileEls[pileIndex].lastElementChild;
              sourceWasTableau = true;
              sourceTableauPileIndex = pileIndex;
            }
          }

          if (card) {
            const foundationIndex = SUIT_TO_INDEX_MAP[card.suit];
            const foundationPile = foundations[foundationIndex];
            if (canPlaceOnFoundation(card, foundationPile)) {
              saveStateForUndo();
              isAnimating = true;
              updateScore(15);
              await animateCardMove(sourceEl, foundationPileEls[foundationIndex]);
              foundationPile.push(sourceArray.pop());

              if (sourceWasTableau) {
                const sourceTableauPile = tableau[sourceTableauPileIndex];
                const sourceTableauEl = tableauPileEls[sourceTableauPileIndex];
                await flipTopTableauCard(sourceTableauPile, sourceTableauEl);
              }

              isAnimating = false;
              renderAll();
              checkWinCondition();
            }
          }
        });

        // Button Listeners
        newGameBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', restartGame);
        winNewGameBtn.addEventListener('click', startGame);
        undoBtn.addEventListener('click', undoMove);
        hintBtn.addEventListener('click', showHint);
        autoCompleteBtn.addEventListener('click', startAutoComplete);

        // Start the game on page load
        startGame();
      });
    </script>
  </body>
</html>
